import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import AxiosInstance from '../AxiosInstance';

// Notification types based on the backend model
export enum NotificationType {
  MATERIAL = 'material',
  INVOICE = 'invoice',
  STOCK_IN = 'stock-in',
  USER = 'user',
  SYSTEM = 'system',
}

export enum NotificationPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent',
}

export enum NotificationStatus {
  UNREAD = 'unread',
  READ = 'read',
  ARCHIVED = 'archived',
}

// User interface for populated data
interface NotificationUser {
  _id: string;
  username: string;
  fullname: string;
}

// Main Notification interface
export interface Notification {
  _id: string;
  title: string;
  message: string;
  type: NotificationType;
  priority: NotificationPriority;
  status: NotificationStatus;
  userId?: NotificationUser;
  relatedEntityId?: string;
  relatedEntityType?: string;
  metadata?: any;
  isAutoGenerated: boolean;
  expiresAt?: string;
  readAt?: string;
  isDeleted: boolean;
  createdAt: string;
  updatedAt: string;
}

// DTOs for API calls
export interface CreateNotificationDto {
  title: string;
  message: string;
  type: NotificationType;
  priority: NotificationPriority;
  userId?: string;
  relatedEntityId?: string;
  relatedEntityType?: string;
  metadata?: any;
  isAutoGenerated?: boolean;
  expiresAt?: string;
}

export interface UpdateNotificationDto {
  title?: string;
  message?: string;
  priority?: NotificationPriority;
  status?: NotificationStatus;
  relatedEntityId?: string;
  relatedEntityType?: string;
  metadata?: any;
  expiresAt?: string;
}

export interface NotificationQueryDto {
  type?: NotificationType;
  priority?: NotificationPriority;
  status?: NotificationStatus;
  userId?: string;
  isAutoGenerated?: boolean;
  search?: string;
  page?: string;
  limit?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

// API Response types - matching backend response format
interface ApiResponse<T> {
  success: boolean;
  message: string;
  data: T;
}

interface NotificationListResponse {
  notifications: Notification[];
  total: number;
  page: number;
  limit: number;
}

interface UnreadCountResponse {
  unreadCount: number;
}

interface ModifiedCountResponse {
  modifiedCount: number;
}

interface DeletedCountResponse {
  deletedCount: number;
}

// State interface
interface NotificationState {
  notifications: Notification[];
  unreadCount: number;
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  isLoadingMore: boolean;
  hasMore: boolean;
  error: string | null;
  filters: {
    type?: NotificationType;
    priority?: NotificationPriority;
    status?: NotificationStatus;
    search?: string;
    isAutoGenerated?: boolean;
  };
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
  selectedNotification: Notification | null;
}

const initialState: NotificationState = {
  notifications: [],
  unreadCount: 0,
  isLoading: false,
  isCreating: false,
  isUpdating: false,
  isDeleting: false,
  isLoadingMore: false,
  hasMore: true,
  error: null,
  filters: {},
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
  },
  selectedNotification: null,
};

// Async thunks for API calls
export const fetchNotifications = createAsyncThunk(
  'notifications/fetchNotifications',
  async (query: NotificationQueryDto = {}, { rejectWithValue }) => {
    try {
      console.log('Fetching notifications with query:', query);
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get('/notifications', { params: query });
      console.log('Notifications API response:', response.data);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<NotificationListResponse>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to fetch notifications');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      console.error('Error fetching notifications:', error);
      console.error('Error response:', error.response?.data);
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to fetch notifications';
      return rejectWithValue(errorMessage);
    }
  }
);

export const loadMoreNotifications = createAsyncThunk(
  'notifications/loadMoreNotifications',
  async (query: NotificationQueryDto = {}, { rejectWithValue, getState }) => {
    try {
      const state = getState() as { notifications: NotificationState };
      const currentPage = state.notifications.pagination.page;
      const nextPage = currentPage + 1;
      
      console.log('Loading more notifications for page:', nextPage);
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get('/notifications', { 
        params: { ...query, page: nextPage.toString() } 
      });
      console.log('Load more notifications API response:', response.data);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<NotificationListResponse>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to load more notifications');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      console.error('Error loading more notifications:', error);
      console.error('Error response:', error.response?.data);
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to load more notifications';
      return rejectWithValue(errorMessage);
    }
  }
);

export const fetchNotificationById = createAsyncThunk(
  'notifications/fetchNotificationById',
  async (id: string, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get(`/notifications/${id}`);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to fetch notification');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to fetch notification';
      return rejectWithValue(errorMessage);
    }
  }
);

export const createNotification = createAsyncThunk(
  'notifications/createNotification',
  async (notificationData: CreateNotificationDto, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.post('/notifications', notificationData);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to create notification');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to create notification';
      return rejectWithValue(errorMessage);
    }
  }
);

export const updateNotification = createAsyncThunk(
  'notifications/updateNotification',
  async ({ id, updateData }: { id: string; updateData: UpdateNotificationDto }, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.patch(`/notifications/${id}`, updateData);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to update notification');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to update notification';
      return rejectWithValue(errorMessage);
    }
  }
);

export const deleteNotification = createAsyncThunk(
  'notifications/deleteNotification',
  async (id: string, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.delete(`/notifications/${id}`);
      
      // Backend returns { success, message } format for delete
      const apiResponse = response.data as ApiResponse<null>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to delete notification');
      }
      
      return id;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to delete notification';
      return rejectWithValue(errorMessage);
    }
  }
);

export const markAsRead = createAsyncThunk(
  'notifications/markAsRead',
  async (id: string, { rejectWithValue }) => {
    try {
      console.log('markAsRead API call - ID:', id);
      const axiosInstance = AxiosInstance();
      const url = `/notifications/${id}/read`;
      console.log('markAsRead API call - URL:', url);
      
      const response = await axiosInstance.patch(url);
      console.log('markAsRead API response:', response.data);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification>;
      if (!apiResponse.success) {
        console.error('markAsRead API - Backend returned success: false', apiResponse);
        return rejectWithValue(apiResponse.message || 'Failed to mark notification as read');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      console.error('markAsRead API error:', error);
      console.error('markAsRead API error response:', error.response?.data);
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to mark notification as read';
      return rejectWithValue(errorMessage);
    }
  }
);

export const markAsUnread = createAsyncThunk(
  'notifications/markAsUnread',
  async (id: string, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.patch(`/notifications/${id}/unread`);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to mark notification as unread');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to mark notification as unread';
      return rejectWithValue(errorMessage);
    }
  }
);

export const markAllAsRead = createAsyncThunk(
  'notifications/markAllAsRead',
  async (_, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.patch('/notifications/mark-all-read');
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<ModifiedCountResponse>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to mark all notifications as read');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to mark all notifications as read';
      return rejectWithValue(errorMessage);
    }
  }
);

export const getUnreadCount = createAsyncThunk(
  'notifications/getUnreadCount',
  async (_, { rejectWithValue }) => {
    try {
      console.log('Fetching unread count...');
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get('/notifications/unread-count');
      console.log('Unread count API response:', response.data);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<UnreadCountResponse>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to get unread count');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      console.error('Error fetching unread count:', error);
      console.error('Error response:', error.response?.data);
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to get unread count';
      return rejectWithValue(errorMessage);
    }
  }
);

export const fetchNotificationsByType = createAsyncThunk(
  'notifications/fetchNotificationsByType',
  async (type: NotificationType, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get(`/notifications/type/${type}`);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification[]>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to fetch notifications by type');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to fetch notifications by type';
      return rejectWithValue(errorMessage);
    }
  }
);

export const fetchNotificationsByPriority = createAsyncThunk(
  'notifications/fetchNotificationsByPriority',
  async (priority: NotificationPriority, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get(`/notifications/priority/${priority}`);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification[]>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to fetch notifications by priority');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to fetch notifications by priority';
      return rejectWithValue(errorMessage);
    }
  }
);

export const fetchSystemNotifications = createAsyncThunk(
  'notifications/fetchSystemNotifications',
  async (_, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get('/notifications/system');
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification[]>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to fetch system notifications');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to fetch system notifications';
      return rejectWithValue(errorMessage);
    }
  }
);

export const fetchAutoGeneratedNotifications = createAsyncThunk(
  'notifications/fetchAutoGeneratedNotifications',
  async (_, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.get('/notifications/auto-generated');
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification[]>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to fetch auto-generated notifications');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to fetch auto-generated notifications';
      return rejectWithValue(errorMessage);
    }
  }
);

export const createBroadcastNotification = createAsyncThunk(
  'notifications/createBroadcastNotification',
  async (data: { title: string; message: string; priority?: NotificationPriority; metadata?: any }, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.post('/notifications/system/broadcast', data);
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<Notification>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to create broadcast notification');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to create broadcast notification';
      return rejectWithValue(errorMessage);
    }
  }
);

export const cleanupExpiredNotifications = createAsyncThunk(
  'notifications/cleanupExpiredNotifications',
  async (_, { rejectWithValue }) => {
    try {
      const axiosInstance = AxiosInstance();
      const response = await axiosInstance.delete('/notifications/cleanup/expired');
      
      // Backend returns { success, message, data } format
      const apiResponse = response.data as ApiResponse<DeletedCountResponse>;
      if (!apiResponse.success) {
        return rejectWithValue(apiResponse.message || 'Failed to cleanup expired notifications');
      }
      
      return apiResponse.data;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || error.response?.data?.error || 'Failed to cleanup expired notifications';
      return rejectWithValue(errorMessage);
    }
  }
);

// Notification slice
const notificationSlice = createSlice({
  name: 'notifications',
  initialState,
  reducers: {
    setSelectedNotification: (state, action: PayloadAction<Notification | null>) => {
      state.selectedNotification = action.payload;
    },
    updateFilters: (state, action: PayloadAction<Partial<NotificationState['filters']>>) => {
      state.filters = { ...state.filters, ...action.payload };
    },
    clearFilters: (state) => {
      state.filters = {};
    },
    setPagination: (state, action: PayloadAction<Partial<NotificationState['pagination']>>) => {
      state.pagination = { ...state.pagination, ...action.payload };
    },
    clearError: (state) => {
      state.error = null;
    },
    // Local actions for optimistic updates
    markNotificationAsRead: (state, action: PayloadAction<string>) => {
      const notification = state.notifications.find(n => n._id === action.payload);
      if (notification) {
        notification.status = NotificationStatus.READ;
        notification.readAt = new Date().toISOString();
      }
      if (state.selectedNotification?._id === action.payload) {
        state.selectedNotification.status = NotificationStatus.READ;
        state.selectedNotification.readAt = new Date().toISOString();
      }
    },
    markNotificationAsUnread: (state, action: PayloadAction<string>) => {
      const notification = state.notifications.find(n => n._id === action.payload);
      if (notification) {
        notification.status = NotificationStatus.UNREAD;
        notification.readAt = undefined;
      }
      if (state.selectedNotification?._id === action.payload) {
        state.selectedNotification.status = NotificationStatus.UNREAD;
        state.selectedNotification.readAt = undefined;
      }
    },
    addNotification: (state, action: PayloadAction<Notification>) => {
      state.notifications.unshift(action.payload);
      state.pagination.total += 1;
      // Update unread count if the new notification is unread
      if (action.payload.status === NotificationStatus.UNREAD) {
        state.unreadCount += 1;
      }
    },
    removeNotification: (state, action: PayloadAction<string>) => {
      const notificationToRemove = state.notifications.find(n => n._id === action.payload);
      state.notifications = state.notifications.filter(n => n._id !== action.payload);
      state.pagination.total -= 1;
      // Update unread count if the removed notification was unread
      if (notificationToRemove && notificationToRemove.status === NotificationStatus.UNREAD) {
        state.unreadCount = Math.max(0, state.unreadCount - 1);
      }
      if (state.selectedNotification?._id === action.payload) {
        state.selectedNotification = null;
      }
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch Notifications
      .addCase(fetchNotifications.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchNotifications.fulfilled, (state, action) => {
        state.isLoading = false;
        state.notifications = action.payload.notifications;
        state.pagination = {
          page: action.payload.page,
          limit: action.payload.limit,
          total: action.payload.total,
          totalPages: Math.ceil(action.payload.total / action.payload.limit),
        };
        state.hasMore = action.payload.page < Math.ceil(action.payload.total / action.payload.limit);
      })
      .addCase(fetchNotifications.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // Load More Notifications
      .addCase(loadMoreNotifications.pending, (state) => {
        state.isLoadingMore = true;
        state.error = null;
      })
      .addCase(loadMoreNotifications.fulfilled, (state, action) => {
        state.isLoadingMore = false;
        state.notifications = [...state.notifications, ...action.payload.notifications];
        state.pagination = {
          page: action.payload.page,
          limit: action.payload.limit,
          total: action.payload.total,
          totalPages: Math.ceil(action.payload.total / action.payload.limit),
        };
        state.hasMore = action.payload.page < Math.ceil(action.payload.total / action.payload.limit);
      })
      .addCase(loadMoreNotifications.rejected, (state, action) => {
        state.isLoadingMore = false;
        state.error = action.payload as string;
      })

      // Fetch Notification by ID
      .addCase(fetchNotificationById.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchNotificationById.fulfilled, (state, action) => {
        state.isLoading = false;
        state.selectedNotification = action.payload;
      })
      .addCase(fetchNotificationById.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // Create Notification
      .addCase(createNotification.pending, (state) => {
        state.isCreating = true;
        state.error = null;
      })
      .addCase(createNotification.fulfilled, (state, action) => {
        state.isCreating = false;
        state.notifications.unshift(action.payload);
        state.pagination.total += 1;
        // Update unread count if the new notification is unread
        if (action.payload.status === NotificationStatus.UNREAD) {
          state.unreadCount += 1;
        }
      })
      .addCase(createNotification.rejected, (state, action) => {
        state.isCreating = false;
        state.error = action.payload as string;
      })

      // Update Notification
      .addCase(updateNotification.pending, (state) => {
        state.isUpdating = true;
        state.error = null;
      })
      .addCase(updateNotification.fulfilled, (state, action) => {
        state.isUpdating = false;
        const index = state.notifications.findIndex(n => n._id === action.payload._id);
        if (index !== -1) {
          state.notifications[index] = action.payload;
        }
        if (state.selectedNotification?._id === action.payload._id) {
          state.selectedNotification = action.payload;
        }
      })
      .addCase(updateNotification.rejected, (state, action) => {
        state.isUpdating = false;
        state.error = action.payload as string;
      })

      // Delete Notification
      .addCase(deleteNotification.pending, (state) => {
        state.isDeleting = true;
        state.error = null;
      })
      .addCase(deleteNotification.fulfilled, (state, action) => {
        state.isDeleting = false;
        state.notifications = state.notifications.filter(n => n._id !== action.payload);
        state.pagination.total -= 1;
        if (state.selectedNotification?._id === action.payload) {
          state.selectedNotification = null;
        }
      })
      .addCase(deleteNotification.rejected, (state, action) => {
        state.isDeleting = false;
        state.error = action.payload as string;
      })

      // Mark as Read
      .addCase(markAsRead.pending, (state) => {
        state.isUpdating = true;
        state.error = null;
      })
      .addCase(markAsRead.fulfilled, (state, action) => {
        state.isUpdating = false;
        const index = state.notifications.findIndex(n => n._id === action.payload._id);
        if (index !== -1) {
          state.notifications[index] = action.payload;
        }
        if (state.selectedNotification?._id === action.payload._id) {
          state.selectedNotification = action.payload;
        }
        // Update unread count
        if (action.payload.status === NotificationStatus.READ) {
          state.unreadCount = Math.max(0, state.unreadCount - 1);
        }
      })
      .addCase(markAsRead.rejected, (state, action) => {
        state.isUpdating = false;
        state.error = action.payload as string;
      })

      // Mark as Unread
      .addCase(markAsUnread.pending, (state) => {
        state.isUpdating = true;
        state.error = null;
      })
      .addCase(markAsUnread.fulfilled, (state, action) => {
        state.isUpdating = false;
        const index = state.notifications.findIndex(n => n._id === action.payload._id);
        if (index !== -1) {
          state.notifications[index] = action.payload;
        }
        if (state.selectedNotification?._id === action.payload._id) {
          state.selectedNotification = action.payload;
        }
        // Update unread count
        if (action.payload.status === NotificationStatus.UNREAD) {
          state.unreadCount += 1;
        }
      })
      .addCase(markAsUnread.rejected, (state, action) => {
        state.isUpdating = false;
        state.error = action.payload as string;
      })

      // Mark All as Read
      .addCase(markAllAsRead.pending, (state) => {
        state.isUpdating = true;
        state.error = null;
      })
      .addCase(markAllAsRead.fulfilled, (state, action) => {
        state.isUpdating = false;
        // Update all unread notifications to read
        // Note: Backend has a bug where it sets status to UNREAD instead of READ
        // So we manually update the status to READ on the frontend
        state.notifications.forEach(notification => {
          if (notification.status === NotificationStatus.UNREAD) {
            notification.status = NotificationStatus.READ;
            notification.readAt = new Date().toISOString();
          }
        });
        state.unreadCount = 0;
      })
      .addCase(markAllAsRead.rejected, (state, action) => {
        state.isUpdating = false;
        state.error = action.payload as string;
      })

      // Get Unread Count
      .addCase(getUnreadCount.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(getUnreadCount.fulfilled, (state, action) => {
        state.isLoading = false;
        state.unreadCount = action.payload.unreadCount;
      })
      .addCase(getUnreadCount.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // Fetch by Type
      .addCase(fetchNotificationsByType.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchNotificationsByType.fulfilled, (state, action) => {
        state.isLoading = false;
        state.notifications = action.payload;
      })
      .addCase(fetchNotificationsByType.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // Fetch by Priority
      .addCase(fetchNotificationsByPriority.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchNotificationsByPriority.fulfilled, (state, action) => {
        state.isLoading = false;
        state.notifications = action.payload;
      })
      .addCase(fetchNotificationsByPriority.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // Fetch System Notifications
      .addCase(fetchSystemNotifications.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchSystemNotifications.fulfilled, (state, action) => {
        state.isLoading = false;
        state.notifications = action.payload;
      })
      .addCase(fetchSystemNotifications.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // Fetch Auto Generated Notifications
      .addCase(fetchAutoGeneratedNotifications.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchAutoGeneratedNotifications.fulfilled, (state, action) => {
        state.isLoading = false;
        state.notifications = action.payload;
      })
      .addCase(fetchAutoGeneratedNotifications.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })

      // Create Broadcast Notification
      .addCase(createBroadcastNotification.pending, (state) => {
        state.isCreating = true;
        state.error = null;
      })
      .addCase(createBroadcastNotification.fulfilled, (state, action) => {
        state.isCreating = false;
        state.notifications.unshift(action.payload);
        state.pagination.total += 1;
        // Update unread count if the new notification is unread
        if (action.payload.status === NotificationStatus.UNREAD) {
          state.unreadCount += 1;
        }
      })
      .addCase(createBroadcastNotification.rejected, (state, action) => {
        state.isCreating = false;
        state.error = action.payload as string;
      })

      // Cleanup Expired Notifications
      .addCase(cleanupExpiredNotifications.pending, (state) => {
        state.isDeleting = true;
        state.error = null;
      })
      .addCase(cleanupExpiredNotifications.fulfilled, (state, action) => {
        state.isDeleting = false;
        // Remove expired notifications from the list
        state.notifications = state.notifications.filter(notification => 
          !notification.expiresAt || new Date(notification.expiresAt) > new Date()
        );
        state.pagination.total -= action.payload.deletedCount;
      })
      .addCase(cleanupExpiredNotifications.rejected, (state, action) => {
        state.isDeleting = false;
        state.error = action.payload as string;
      });
  },
});

export const {
  setSelectedNotification,
  updateFilters,
  clearFilters,
  setPagination,
  clearError,
  markNotificationAsRead,
  markNotificationAsUnread,
  addNotification,
  removeNotification,
} = notificationSlice.actions;

export default notificationSlice.reducer;

// Selectors
export const selectNotifications = (state: { notifications: NotificationState }) => state.notifications.notifications;
export const selectUnreadCount = (state: { notifications: NotificationState }) => state.notifications.unreadCount;
export const selectNotificationsLoading = (state: { notifications: NotificationState }) => state.notifications.isLoading;
export const selectNotificationsLoadingMore = (state: { notifications: NotificationState }) => state.notifications.isLoadingMore;
export const selectNotificationsHasMore = (state: { notifications: NotificationState }) => state.notifications.hasMore;
export const selectNotificationsCreating = (state: { notifications: NotificationState }) => state.notifications.isCreating;
export const selectNotificationsUpdating = (state: { notifications: NotificationState }) => state.notifications.isUpdating;
export const selectNotificationsDeleting = (state: { notifications: NotificationState }) => state.notifications.isDeleting;
export const selectNotificationsError = (state: { notifications: NotificationState }) => state.notifications.error;
export const selectNotificationsFilters = (state: { notifications: NotificationState }) => state.notifications.filters;
export const selectNotificationsPagination = (state: { notifications: NotificationState }) => state.notifications.pagination;
export const selectSelectedNotification = (state: { notifications: NotificationState }) => state.notifications.selectedNotification;

// Computed selectors
export const selectUnreadNotifications = (state: { notifications: NotificationState }) => 
  state.notifications.notifications.filter(n => n.status === NotificationStatus.UNREAD);

export const selectReadNotifications = (state: { notifications: NotificationState }) => 
  state.notifications.notifications.filter(n => n.status === NotificationStatus.READ);

export const selectNotificationsByType = (state: { notifications: NotificationState }, type: NotificationType) => 
  state.notifications.notifications.filter(n => n.type === type);

export const selectNotificationsByPriority = (state: { notifications: NotificationState }, priority: NotificationPriority) => 
  state.notifications.notifications.filter(n => n.priority === priority);

export const selectSystemNotifications = (state: { notifications: NotificationState }) => 
  state.notifications.notifications.filter(n => n.type === NotificationType.SYSTEM);

export const selectAutoGeneratedNotifications = (state: { notifications: NotificationState }) => 
  state.notifications.notifications.filter(n => n.isAutoGenerated);

export const selectFilteredNotifications = (state: { notifications: NotificationState }) => {
  const { notifications, filters } = state.notifications;
  
  return notifications.filter(notification => {
    const matchesType = !filters.type || notification.type === filters.type;
    const matchesPriority = !filters.priority || notification.priority === filters.priority;
    const matchesStatus = !filters.status || notification.status === filters.status;
    const matchesAutoGenerated = filters.isAutoGenerated === undefined || notification.isAutoGenerated === filters.isAutoGenerated;
    const matchesSearch = !filters.search || 
      notification.title.toLowerCase().includes(filters.search.toLowerCase()) ||
      notification.message.toLowerCase().includes(filters.search.toLowerCase());
    
    return matchesType && matchesPriority && matchesStatus && matchesAutoGenerated && matchesSearch;
  });
};

export const selectNotificationStats = (state: { notifications: NotificationState }) => {
  const notifications = state.notifications.notifications;
  const unreadCount = state.notifications.unreadCount;
  
  const byType = notifications.reduce((acc, n) => {
    acc[n.type] = (acc[n.type] || 0) + 1;
    return acc;
  }, {} as Record<NotificationType, number>);
  
  const byPriority = notifications.reduce((acc, n) => {
    acc[n.priority] = (acc[n.priority] || 0) + 1;
    return acc;
  }, {} as Record<NotificationPriority, number>);
  
  return {
    total: notifications.length,
    unread: unreadCount,
    read: notifications.length - unreadCount,
    byType,
    byPriority,
    autoGenerated: notifications.filter(n => n.isAutoGenerated).length,
    system: notifications.filter(n => n.type === NotificationType.SYSTEM).length,
  };
};
